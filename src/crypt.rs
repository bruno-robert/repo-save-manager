use aes;
use aes::cipher::{BlockDecryptMut, KeyIvInit, block_padding::Pkcs7};
use cbc;
use flate2;
use pbkdf2;
use sha1::Sha1;
use std::io::Read;
use std::path::Path;
use std::str;
use thiserror::Error;

type Aes128CbcDec = cbc::Decryptor<aes::Aes128>;

#[derive(Error, Debug)]
pub enum DecryptError {
    #[error("Failed to read file: {0}")]
    IoError(#[from] std::io::Error),
    #[error("Invalid encrypted data format")]
    InvalidFormat,
    #[error("Decryption failed: {0}")]
    DecryptionError(String),
    #[error("Decompression failed: {0}")]
    DecompressionError(String),
}

/// Decrypt an es3 file, returning decrypted bytes (which should be JSON)
/// The es3 save files are encrypted JSON and sometimes gzipped JSON.
/// The data is encrypted using AES-128-CBC, a symetric encryption algorithm that combines:
/// 1. AES (Advanced Encryption Standard): A block cipher algorithm
/// - Uses 128-bit key length
/// - Processes data in fixed 128-bit blocks
/// - Considered very secure and widely used
///
/// 2. CBC (Cipher Block Chaining): An operation mode that:
/// - Links each block of encrypted data to the previous one
/// - Uses an Initialization Vector (IV) for the first block
/// - Adds randomization to prevent identical plaintext blocks from producing identical ciphertext
///
/// The first 16 bytes of data is the IV, the remaining bytes are encrypted data.
pub fn decrypt_es3(file_path: &Path, password: &str) -> Result<Vec<u8>, DecryptError> {
    // Read encrypted data
    let encrypted_data = std::fs::read(file_path)?;

    // Ensure we have at least enough data for IV
    if encrypted_data.len() < 16 {
        return Err(DecryptError::InvalidFormat);
    }

    // Extract IV and encrypted data
    let iv = &encrypted_data[..16];
    let cypher_text = &encrypted_data[16..];

    // Derive key using PBKDF2
    // TODO: could be optimised by storing the byte array generated by this function
    //       call so as to not have to compute it at runtime.
    let mut key = [0u8; 16];
    pbkdf2::pbkdf2_hmac::<Sha1>(password.as_bytes(), iv, 100, &mut key);

    // Create cipher instance and decrypt
    let decryptor = Aes128CbcDec::new(&key.into(), iv.into());

    let decrypted_bytes = decryptor
        .decrypt_padded_vec_mut::<Pkcs7>(&cypher_text)
        .unwrap();

    // Check for GZip compression (magic number 0x1f, 0x8b)
    if decrypted_bytes.starts_with(&[0x1f, 0x8b]) {
        let mut decoder = flate2::read::GzDecoder::new(&decrypted_bytes[..]);
        let mut decompressed = Vec::new();
        decoder
            .read_to_end(&mut decompressed)
            .map_err(|e| DecryptError::DecompressionError(e.to_string()))?;
        Ok(decompressed)
    } else {
        Ok(decrypted_bytes)
    }
}
